# -*- coding: utf-8 -*-
"""array.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B23GLEO61c5r5PKFVGTZ7i23Y_PIPTsv

**Basic**
- Good for access with index
- Append takes O(1) on average
- Insert and Remove take O(n)

**Tips**
- Fill items from the back
- Instead of deleting, consider overwriting
- Process from the back when moving items around
- Comfortable with subarray, partitioning (Dutch flag), merging

**Python specifics**
- `len, append, remove, insert, min, max`
- Difference between `copy` and `deepcopy`
- `A.reverse()` (in-place) vs `reversed(A)` (returns an iterator), `A.sort()` (in-place) vs `sorted(A)` (returns a copy), `del A[i]` (deletes the i-th element), `del A[i:j]` (removes the slice)

### 1. Dutch Flag
Rearrange the elements such that all elements less than A[i] appear first, followed by elements equal to the pivot, followed by elements greater than the pivot
"""

def dutch_flag_partition(A, p):
    '''
    bottom = A[:smaller]
    equal = A[smaller:equal]
    unclassified = A[equal:larger]
    top = A[larger:]
    '''
    smaller, equal, larger = 0, 0, len(A)
    pivot = A[p]

    while equal < larger:
        if A[equal] < pivot:
            # Increase bottom size
            A[smaller], A[equal] = A[equal], A[smaller]
            smaller, equal = smaller+1, equal+1
        elif A[equal] == pivot:
            # Increase equal size
            equal += 1
        else:
            #Increase top size
            larger -= 1
            A[equal], A[larger] = A[larger], A[equal]
    return A

# a = [1,4,5,5,3,1,0,9,10,22,1]
# print(dutch_flag_partition(a, 2))

"""### 2. Multiply arrays
Given 2 arrays, multiply the numbers formed by them and give the result in array-form. For example: [1,2,3] * [9,8,7] = [1,2,1,4,0,1]
"""

def multiply(A1, A2):
    sign = 1 if (A1[0] * A2[0]) < 0 else 1
    A1[0], A2[0] = abs(A1[0]), abs(A2[0])
    result = [0] * (len(A1)+len(A2))

    for i in reversed(range(len(A1))):
        for j in reversed(range(len(A2))):
            result[i+j+1] += A1[i] * A2[j]
            result[i+j] += result[i+j+1] // 10
            result[i+j+1] = result[i+j+1] % 10
    
    result = result[next((i for i,x in enumerate(result) if x != 0), len(result)):]
    return [result[0]*sign] + result[1:]

# print(multiply([1,2,3], [9,8,7]))

"""### Palindrome Permutation

Check if a string is a permutation of a palindrome. For example: "Tact Coa" is PP because valid permutations are "taco cat", "atco cta"
"""
def is_palindrome_permutation(s):
    s = s.replace(' ', '').lower()
    track = set()
    for i in s:
        if i in track:
            track.remove(i)
        else:
            track.add(i)
    
    if len(track) <= 1:
        return 1
    return 0

# print(is_palindrome_permutation('tacoo0o c011at'))

